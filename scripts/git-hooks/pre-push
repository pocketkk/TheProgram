#!/bin/bash
# Pre-push hook: Scan for secrets before pushing to remote
# Prevents accidental exposure of API keys, passwords, and sensitive data

set -e

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Running secret scan before push...${NC}"

# Get the range of commits being pushed
z40=0000000000000000000000000000000000000000
while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" = "$z40" ]; then
        # Deleting branch, nothing to check
        continue
    fi

    if [ "$remote_sha" = "$z40" ]; then
        # New branch, check all commits
        range="$local_sha"
    else
        # Existing branch, check new commits
        range="$remote_sha..$local_sha"
    fi

    # Get list of files changed in this push
    files=$(git diff --name-only "$range" 2>/dev/null || git diff-tree --no-commit-id --name-only -r "$local_sha")

    if [ -z "$files" ]; then
        continue
    fi

    # Pattern definitions for secrets
    PATTERNS=(
        # Anthropic API keys
        'sk-ant-[a-zA-Z0-9_-]{20,}'
        # OpenAI API keys
        'sk-[a-zA-Z0-9]{48}'
        # Generic API key patterns (long hex strings that look like keys)
        'api[_-]?key["\x27]?\s*[:=]\s*["\x27][a-zA-Z0-9_-]{32,}["\x27]'
        # AWS Access Keys
        'AKIA[0-9A-Z]{16}'
        # AWS Secret Keys
        'aws[_-]?secret[_-]?access[_-]?key.*[=:][^a-zA-Z0-9]*[a-zA-Z0-9/+=]{40}'
        # Private keys
        '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----'
        # GitHub tokens
        'gh[pousr]_[A-Za-z0-9_]{36,}'
        # Generic secret patterns
        'secret[_-]?key["\x27]?\s*[:=]\s*["\x27][a-zA-Z0-9_-]{20,}["\x27]'
        # Password in config (not placeholder)
        'password["\x27]?\s*[:=]\s*["\x27][^"\x27]{8,}["\x27]'
    )

    FOUND_SECRETS=0

    for file in $files; do
        # Skip if file doesn't exist (deleted) or is binary
        if [ ! -f "$file" ] || [ ! -s "$file" ]; then
            continue
        fi

        # Skip known safe files and git hooks (they contain patterns)
        case "$file" in
            *.md|*.txt|*.rst|*.example|*.sample|*test*|*mock*|*.lock|package-lock.json|yarn.lock|*/git-hooks/*)
                continue
                ;;
        esac

        # Check for .env files being committed (should never happen)
        if [[ "$file" == ".env" || "$file" == *"/.env" ]]; then
            echo -e "${RED}ERROR: Attempting to commit .env file: $file${NC}"
            echo -e "${RED}.env files must never be committed to version control!${NC}"
            FOUND_SECRETS=1
            continue
        fi

        # Run secret patterns against the file content
        for pattern in "${PATTERNS[@]}"; do
            if grep -qE "$pattern" "$file" 2>/dev/null; then
                # Double-check it's not a placeholder/example
                matches=$(grep -E "$pattern" "$file" 2>/dev/null || true)
                if echo "$matches" | grep -qvE '(example|placeholder|your-|xxx|CHANGE_ME|REDACTED|TODO|dummy|fake|test|sample)'; then
                    echo -e "${RED}POTENTIAL SECRET FOUND in $file:${NC}"
                    echo "$matches" | head -3
                    FOUND_SECRETS=1
                fi
            fi
        done
    done

    if [ $FOUND_SECRETS -eq 1 ]; then
        echo ""
        echo -e "${RED}========================================${NC}"
        echo -e "${RED}PUSH BLOCKED: Potential secrets detected${NC}"
        echo -e "${RED}========================================${NC}"
        echo ""
        echo "Please review and remove any secrets before pushing."
        echo "If these are false positives, you can:"
        echo "  1. Use placeholder values (e.g., 'your-api-key-here')"
        echo "  2. Move secrets to .env files (which are gitignored)"
        echo "  3. Bypass with: git push --no-verify (NOT RECOMMENDED)"
        echo ""
        exit 1
    fi
done

echo -e "${GREEN}Secret scan passed. Proceeding with push.${NC}"
exit 0
