/**
 * Birth Chart Wheel - SVG-based circular astrological chart
 */

import { motion } from 'framer-motion'
import { useRef, useMemo } from 'react'
import type { BirthChart, AspectType } from '@/lib/astrology/types'
import { ZODIAC_SIGNS, PLANETS, ASPECT_CONFIG } from '@/lib/astrology/types'
import { useChartInteractions, useChartKeyboardNav } from '../hooks/useChartInteractions'
import { useChartStore } from '../stores/chartStore'
import { ChartTooltip } from './ChartTooltip'
import { DegreeMarkersLayer } from './layers/DegreeMarkersLayer'
import { PatternHighlight } from './patterns/PatternHighlight'
import { clusterPlanets } from '../utils/planetClustering'
import {
  wheelVariants,
  zodiacSegmentVariants,
  houseCuspVariants,
  aspectLineVariants,
  planetEntranceVariants,
  planetHoverVariants,
  planetSelectionVariants,
  retrogradeVariants,
  getPlanetEntranceDelay,
  withReducedMotion,
} from '../animations'

interface BirthChartWheelProps {
  chart: BirthChart
  showAspects?: boolean
  showHouseNumbers?: boolean
  size?: number
}

export function BirthChartWheel({
  chart,
  showAspects = true,
  showHouseNumbers = true,
  size = 600,
}: BirthChartWheelProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const visibility = useChartStore(state => state.visibility)
  const selectedPattern = useChartStore(state => state.interaction.selectedPattern)
  const {
    onPlanetHover,
    onPlanetClick,
    onHouseClick,
    clearHover,
    isSelected,
    isHighlighted,
  } = useChartInteractions()

  // Enable keyboard navigation
  useChartKeyboardNav()
  const center = size / 2
  const outerRadius = size / 2 - 20
  const innerRadius = outerRadius * 0.75
  const planetRadius = outerRadius * 0.85
  const houseRadius = outerRadius * 0.65

  // Define major and minor aspect types
  const majorAspects: AspectType[] = ['Conjunction', 'Sextile', 'Square', 'Trine', 'Opposition']
  const minorAspects: AspectType[] = ['Quincunx', 'Semisextile', 'Semisquare', 'Sesquiquadrate']

  // Filter aspects based on visibility settings
  const filteredAspects = useMemo(() => {
    return chart.aspects.filter(aspect => {
      // Filter by orb
      if (aspect.orb > visibility.maxOrb) return false

      // Filter by aspect type (major/minor)
      const isMajor = majorAspects.includes(aspect.type)
      const isMinor = minorAspects.includes(aspect.type)

      if (isMajor && !visibility.aspectTypes.major) return false
      if (isMinor && !visibility.aspectTypes.minor) return false

      return true
    })
  }, [chart.aspects, visibility.maxOrb, visibility.aspectTypes.major, visibility.aspectTypes.minor])

  // Apply planet clustering to prevent overlaps
  const clusteredPlanets = useMemo(() => {
    return clusterPlanets(chart.planets)
  }, [chart.planets])

  /**
   * Convert longitude to SVG coordinates
   */
  const polarToCartesian = (angle: number, radius: number) => {
    // Start from 9 o'clock (Aries 0°) and go counterclockwise
    const adjustedAngle = (180 - angle) * (Math.PI / 180)
    return {
      x: center + radius * Math.cos(adjustedAngle),
      y: center - radius * Math.sin(adjustedAngle),
    }
  }

  /**
   * Create arc path for zodiac signs
   */
  const createArcPath = (startAngle: number, endAngle: number, radius: number) => {
    const start = polarToCartesian(startAngle, radius)
    const end = polarToCartesian(endAngle, radius)
    const largeArc = endAngle - startAngle > 180 ? 1 : 0

    return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArc} 0 ${end.x} ${end.y}`
  }

  /**
   * Get color for zodiac element
   */
  const getElementColor = (element: string) => {
    const colors = {
      Fire: '#FF6B6B',
      Earth: '#8B7355',
      Air: '#4ECDC4',
      Water: '#4169E1',
    }
    return colors[element as keyof typeof colors] || '#888'
  }

  return (
    <div ref={containerRef} className="relative" style={{ width: size, height: size }}>
      <ChartTooltip containerRef={containerRef} />
      <motion.svg
        width={size}
        height={size}
        className="drop-shadow-2xl"
        variants={withReducedMotion(wheelVariants)}
        initial="initial"
        animate="animate"
      >
        <defs>
          {/* Radial gradient for background */}
          <radialGradient id="chartBg">
            <stop offset="0%" stopColor="#1a1a2e" />
            <stop offset="100%" stopColor="#0f0f1e" />
          </radialGradient>

          {/* Glow filters for planets */}
          <filter id="planetGlow">
            <feGaussianBlur stdDeviation="2" result="coloredBlur" />
            <feMerge>
              <feMergeNode in="coloredBlur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>

        {/* Background circle */}
        <circle cx={center} cy={center} r={outerRadius} fill="url(#chartBg)" />

        {/* Zodiac sign rings */}
        {ZODIAC_SIGNS.map(sign => {
          const index = ZODIAC_SIGNS.indexOf(sign)
          const startAngle = index * 30
          const endAngle = (index + 1) * 30
          const midAngle = startAngle + 15
          const color = getElementColor(sign.element)

          const labelPos = polarToCartesian(midAngle, outerRadius - 30)

          return (
            <motion.g
              key={sign.name}
              custom={index}
              variants={withReducedMotion(zodiacSegmentVariants)}
              initial="initial"
              animate="animate"
            >
              {/* Sign segment background */}
              <path
                d={`
                  ${createArcPath(startAngle, endAngle, outerRadius)}
                  L ${polarToCartesian(endAngle, innerRadius).x} ${polarToCartesian(endAngle, innerRadius).y}
                  ${createArcPath(endAngle, startAngle, innerRadius)}
                  Z
                `}
                fill={color}
                fillOpacity={0.1}
                stroke={color}
                strokeWidth={1}
                strokeOpacity={0.3}
              />

              {/* Sign symbol */}
              <text
                x={labelPos.x}
                y={labelPos.y}
                fontSize={20}
                fill={color}
                textAnchor="middle"
                dominantBaseline="middle"
                fontWeight="bold"
              >
                {sign.symbol}
              </text>
            </motion.g>
          )
        })}

        {/* Degree markers */}
        <DegreeMarkersLayer
          center={center}
          outerRadius={outerRadius}
          visible={visibility.degreeMarkers}
        />

        {/* House cusps */}
        {chart.houses.map((house, index) => {
          const angle = house.cusp
          const start = polarToCartesian(angle, innerRadius)
          const end = polarToCartesian(angle, houseRadius)
          const labelPos = polarToCartesian(angle + 15, houseRadius + 20)
          const selected = isSelected('house', String(house.number))

          return (
            <motion.g
              key={house.number}
              className="cursor-pointer"
              onClick={() => onHouseClick(house)}
              custom={index * 0.03}
              variants={withReducedMotion(houseCuspVariants)}
              initial="initial"
              animate="animate"
            >
              {/* House cusp line */}
              <motion.line
                x1={start.x}
                y1={start.y}
                x2={end.x}
                y2={end.y}
                stroke={selected ? '#60a5fa' : '#4a5568'}
                strokeWidth={selected ? 3 : 2}
                strokeDasharray="4 4"
                className="transition-all"
              />

              {/* House number */}
              {showHouseNumbers && (
                <text
                  x={labelPos.x}
                  y={labelPos.y}
                  fontSize={14}
                  fill={selected ? '#60a5fa' : '#a0aec0'}
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fontWeight="600"
                  className="transition-colors pointer-events-none"
                >
                  {house.number}
                </text>
              )}
            </motion.g>
          )
        })}

        {/* Aspect lines */}
        {showAspects &&
          filteredAspects.map((aspect, index) => {
            const planet1 = chart.planets.find(p => p.name === aspect.planet1)
            const planet2 = chart.planets.find(p => p.name === aspect.planet2)

            if (!planet1 || !planet2) return null

            const pos1 = polarToCartesian(planet1.longitude, planetRadius - 40)
            const pos2 = polarToCartesian(planet2.longitude, planetRadius - 40)

            const config = ASPECT_CONFIG[aspect.type]

            // Check if this aspect is highlighted (related to selected planet)
            const highlighted = isHighlighted(aspect.planet1) || isHighlighted(aspect.planet2)

            return (
              <motion.line
                key={`aspect-${index}`}
                x1={pos1.x}
                y1={pos1.y}
                x2={pos2.x}
                y2={pos2.y}
                stroke={config.color}
                strokeWidth={highlighted ? 3 : aspect.orb < 2 ? 2 : 1}
                strokeOpacity={highlighted ? 0.8 : 0.3}
                strokeDasharray={aspect.isApplying ? 'none' : '4 4'}
                custom={index * 0.02}
                variants={withReducedMotion(aspectLineVariants)}
                initial="initial"
                animate="animate"
                className="transition-all duration-200"
              />
            )
          })}

        {/* Pattern Highlight */}
        {selectedPattern && (
          <PatternHighlight
            pattern={selectedPattern}
            planets={chart.planets}
            polarToCartesian={polarToCartesian}
            planetRadius={planetRadius}
          />
        )}

        {/* Planets (with clustering) */}
        {clusteredPlanets.map((planet, index) => {
          const displayPos = polarToCartesian(planet.displayAngle, planetRadius)
          const actualPos = polarToCartesian(planet.actualAngle, planetRadius - 40)
          const planetConfig = PLANETS.find(p => p.name === planet.name)
          const selected = isSelected('planet', planet.name)
          const highlighted = isHighlighted(planet.name)

          return (
            <motion.g
              key={planet.name}
              custom={index}
              variants={withReducedMotion(planetEntranceVariants)}
              initial="initial"
              animate={selected ? 'selected' : 'animate'}
              onMouseEnter={() => onPlanetHover(planet)}
              onMouseLeave={() => onPlanetHover(null)}
              onClick={() => onPlanetClick(planet)}
              className="cursor-pointer"
            >
              {/* Connection line to actual position (if clustered) */}
              {planet.isClustered && (
                <line
                  x1={displayPos.x}
                  y1={displayPos.y}
                  x2={actualPos.x}
                  y2={actualPos.y}
                  stroke="#8b5cf6"
                  strokeWidth={1}
                  strokeOpacity={0.3}
                  strokeDasharray="2 2"
                  className="pointer-events-none"
                />
              )}

              {/* Selection ring */}
              {selected && (
                <circle
                  cx={displayPos.x}
                  cy={displayPos.y}
                  r={18}
                  fill="none"
                  stroke="#60a5fa"
                  strokeWidth={2}
                  className="animate-pulse"
                />
              )}

              {/* Highlight ring */}
              {!selected && highlighted && (
                <circle
                  cx={displayPos.x}
                  cy={displayPos.y}
                  r={16}
                  fill="none"
                  stroke="#60a5fa"
                  strokeWidth={1}
                  strokeOpacity={0.5}
                />
              )}

              {/* Planet circle */}
              <circle
                cx={displayPos.x}
                cy={displayPos.y}
                r={12}
                fill={planetConfig?.color || '#fff'}
                filter="url(#planetGlow)"
                className="hover:brightness-125 transition-all"
              />

              {/* Planet symbol */}
              <text
                x={displayPos.x}
                y={displayPos.y}
                fontSize={16}
                fill="#000"
                textAnchor="middle"
                dominantBaseline="middle"
                fontWeight="bold"
                className="pointer-events-none"
              >
                {planet.symbol}
              </text>

              {/* Retrograde indicator */}
              {planet.isRetrograde && (
                <motion.text
                  x={displayPos.x + 15}
                  y={displayPos.y - 10}
                  fontSize={10}
                  fill="#ff6b6b"
                  fontWeight="bold"
                  className="pointer-events-none"
                  variants={withReducedMotion(retrogradeVariants)}
                  initial="initial"
                  animate="animate"
                >
                  ℞
                </motion.text>
              )}
            </motion.g>
          )
        })}

        {/* Ascendant marker */}
        <g>
          {(() => {
            const ascPos = polarToCartesian(chart.ascendant, outerRadius + 10)
            return (
              <>
                <circle cx={ascPos.x} cy={ascPos.y} r={8} fill="#FFD700" />
                <text
                  x={ascPos.x}
                  y={ascPos.y}
                  fontSize={12}
                  fill="#000"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fontWeight="bold"
                >
                  AC
                </text>
              </>
            )
          })()}
        </g>

        {/* Midheaven marker */}
        <g>
          {(() => {
            const mcPos = polarToCartesian(chart.midheaven, outerRadius + 10)
            return (
              <>
                <circle cx={mcPos.x} cy={mcPos.y} r={8} fill="#87CEEB" />
                <text
                  x={mcPos.x}
                  y={mcPos.y}
                  fontSize={12}
                  fill="#000"
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fontWeight="bold"
                >
                  MC
                </text>
              </>
            )
          })()}
        </g>

        {/* Center point */}
        <circle cx={center} cy={center} r={3} fill="#a0aec0" />
      </motion.svg>
    </div>
  )
}
